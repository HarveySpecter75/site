
% --- Graph Definitions ---
s(a,b).
s(a,c).
s(b,d).
s(b,e).
s(c,f).
s(c,g).
s(d,h).
s(e,i).
s(e,j).
s(f,k).

% --- Goals ---
goal(f).
goal(j).

% --- Helpers ---
% Member check (standard Prolog logic)
mem(X, [X|_]).
mem(X, [_|Tail]):-
    mem(X, Tail).

% --- DFS Solver ---
solve(Node, Solution):-
    dfs([], Node, Solution).

% Base Case: If Node is a goal, prepend it to Path and return.
dfs(Path, Node, [Node|Path]):-
    goal(Node).

% Recursive Step:
% 1. Find a child (Node1).
% 2. Ensure Node1 is not in the current Path (prevent cycles).
% 3. Recurse, adding current Node to the Path history.
dfs(Path, Node, Sol):-
    s(Node, Node1),
    \+ mem(Node1, Path),
    dfs([Node|Path], Node1, Sol).


?- solve(a,S).
S = [j, e, b, a] ;
S = [f, c, a] .